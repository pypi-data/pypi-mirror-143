import asyncio

from couchbase_core import mk_formstr
from couchbase.options import forward_args
from couchbase.management.generic import Admin
from couchbase.auth import AuthDomain
from typing import Awaitable, Iterable, Any, Dict
from couchbase.exceptions import InvalidArgumentException

from couchbase.management.users import (UserErrorHandler, UserAndMetadata,
                                        GetUserOptions, GetAllUsersOptions, User,
                                        UpsertUserOptions, DropUserOptions,
                                        RoleAndDescription, GetRolesOptions, Group,
                                        GetGroupOptions, GetAllGroupsOptions, UpsertGroupOptions, DropGroupOptions)


@UserErrorHandler.wrap
class AUserManager(object):
    _HANDLE_ERRORS_ASYNC = True

    def __init__(self,         # type: "AUserManager"
                 admin_bucket  # type: Admin
                 ):
        """User Manager
        Programmatic access to the user management REST API:
        https://docs.couchbase.com/server/current/rest-api/rbac.html

        Unless otherwise indicated, all objects SHOULD be immutable.
        :param parent_cluster: """

        self._admin_bucket = admin_bucket

    def get_user(self,      # type: "AUserManager"
                 username,  # type: str
                 *options,  # type: GetUserOptions
                 **kwargs   # type: Any
                 ):
        # type: (...) -> UserAndMetadata
        """
        Gets a user.

        :param str username: ID of the user.
        :param options: GetUserOptions
        :param Any kwargs: override corresponding values in the options.

        :returns: An instance of UserAndMetadata.

        :raises: UserNotFoundException
        :raises: InvalidArgumentsException
        Any exceptions raised by the underlying platform
        """

        # Implementation Notes
        # When parsing the "get" and "getAll" responses,
        # take care to distinguish between roles assigned directly to the user (role origin with type="user") and
        # roles inherited from groups (role origin with type="group" and name=<group name>).
        # If the server response does not include an "origins" field for a role,
        # then it was generated by a server version prior to 6.5 and the SDK MUST treat the role as if it had a
        # single origin of type="user".
        final_args = forward_args(kwargs, *options)
        domain = final_args.pop("domain_name", "local")
        timeout = final_args.pop("timeout", None)
        path = self._admin_bucket._get_management_path(domain, username)
        result = self._admin_bucket.http_request(path=path,
                                                 method='GET',
                                                 timeout=timeout)

        ft = asyncio.Future()

        def on_ok(response):
            ft.set_result(UserAndMetadata.load_from_server(response.value))
            result.clear_callbacks()

        def on_err(_, excls, excval, __):
            err = excls(excval)
            ft.set_exception(err)
            result.clear_callbacks()

        result.set_callbacks(on_ok, on_err)
        return ft

    def get_all_users(self,  # type: "AUserManager"
                      *options,  # type: GetAllUsersOptions
                      **kwargs  # type: Any
                      ):
        # type: (...) -> Iterable[UserAndMetadata]
        """
        Gets all users.

        :param options: GetAllUsersOptions
        :param Any kwargs: override corresponding values in the options.

        :return: An iterable collection of UserAndMetadata.
        """
        final_args = forward_args(kwargs, *options)
        domain = final_args.get("domain_name", "local")
        timeout = final_args.get("timeout", None)
        path = self._admin_bucket._get_management_path(domain)
        result = self._admin_bucket.http_request(path=path,
                                                 method='GET',
                                                 timeout=timeout)

        ft = asyncio.Future()

        def on_ok(response):
            users = list(
                map(lambda u: UserAndMetadata.load_from_server(u), response.value))
            ft.set_result(users)
            result.clear_callbacks()

        def on_err(_, excls, excval, __):
            err = excls(excval)
            ft.set_exception(err)
            result.clear_callbacks()

        result.set_callbacks(on_ok, on_err)
        return ft

    def _upsert_user(self,  # type: "AUserManager"
                     domain,  # type: str
                     username,  # type: str
                     params,  # type: Dict[str, Any]
                     timeout=None  # type: timedelta
                     ) -> Awaitable:
        form = mk_formstr(params)
        path = self._admin_bucket._get_management_path(domain, username)
        result = self._admin_bucket.http_request(path=path,
                                                 method='PUT',
                                                 content_type='application/x-www-form-urlencoded',
                                                 content=form,
                                                 timeout=timeout)

        ft = asyncio.Future()

        def on_ok(response):
            ft.set_result(response.value)
            result.clear_callbacks()

        def on_err(_, excls, excval, __):
            err = excls(excval)
            ft.set_exception(err)
            result.clear_callbacks()

        result.set_callbacks(on_ok, on_err)
        return ft

    async def upsert_user(self,   # type: "AUserManager"
                          user,     # type: User
                          *options,  # type: UpsertUserOptions
                          **kwargs  # type: Any
                          ):
        """
        Creates or updates a user.

        :param User user: the new version of the user.
        :param options: UpsertUserOptions
        :param Any kwargs: override corresponding values in the options.

        :raises: InvalidArgumentsException
        """

        # Implementation Notes
        #
        # When building the PUT request to send to the REST endpoint, implementations MUST omit the "password" property
        # if it is not present in the given User domain object (so that the password is only changed if the calling code
        # provided a new password).

        final_args = forward_args(kwargs, *options)
        domain = final_args.pop("domain_name", "local")
        final_args.update({k: v for k, v in user.as_dict.items() if k in {
                          'password', 'roles', 'name', 'groups'}})

        groups = final_args.get("groups", None)
        roles = final_args.get("roles", None)

        if not groups and (not roles or not isinstance(roles, list)):
            raise InvalidArgumentException("Roles must be a non-empty list")

        if isinstance(domain, AuthDomain):
            domain = AuthDomain.to_str(domain)

        password = final_args.get("password", None)
        if password and domain == "external":
            raise InvalidArgumentException(
                "External domains must not have passwords")

        params = {}
        if roles:
            params['roles'] = ','.join(
                list(map(lambda r: r.to_server_str(), roles)))

        name = final_args.get("name", None)
        # For backwards compatibility with Couchbase Server 6.0 and earlier,
        # the "groups" parameter MUST be omitted if the group list is empty.
        # Couchbase Server 6.5 treats the absent parameter the same as an
        # explicit parameter with no value (removes any existing group associations,
        # which is what we want in this case).
        if groups and await self._admin_bucket._is_6_5_plus_async():
            params['groups'] = ','.join(groups)
        if password:
            params['password'] = password
        if name:
            params['name'] = name

        return await self._upsert_user(domain, user.username, params, final_args.get("timeout", None))

    def drop_user(self,    # type: "AUserManager"
                  username,  # type: str
                  *options,  # type: DropUserOptions
                  **kwargs   # type: Any
                  ):
        """
        Removes a user.

        :param str username: ID of the user.
        :param options: DropUserOptions
        :param Any kwargs: override corresponding values in the options.

        :raises: UserNotFoundException
        :raises: InvalidArgumentsException

        Any exceptions raised by the underlying platform
        """
        final_args = forward_args(kwargs, *options)
        domain = final_args.pop("domain_name", "local")
        timeout = final_args.get("timeout", None)
        path = self._admin_bucket._get_management_path(domain, username)
        result = self._admin_bucket.http_request(path=path,
                                                 method='DELETE',
                                                 timeout=timeout)

        ft = asyncio.Future()

        def on_ok(response):
            ft.set_result(response.value)
            result.clear_callbacks()

        def on_err(_, excls, excval, __):
            err = excls(excval)
            ft.set_exception(err)
            result.clear_callbacks()

        result.set_callbacks(on_ok, on_err)
        return ft

    def get_roles(self,  # type: "AUserManager"
                  *options,  # type: GetRolesOptions
                  **kwargs   # type: Any
                  ):
        # type: (...) -> Iterable[RoleAndDescription]
        """
        Returns the roles supported by the server.

        :param options: GetRolesOptions
        :param Any kwargs: override corresponding values in the options.

        :return: An iterable collection of RoleAndDescription.
        """

        final_args = forward_args(kwargs, *options)
        timeout = final_args.get("timeout", None)
        result = self._admin_bucket.http_request(path="/settings/rbac/roles/",
                                                 method='GET',
                                                 timeout=timeout)

        ft = asyncio.Future()

        def on_ok(response):
            roles = list(
                map(lambda r: RoleAndDescription.load_from_server(r), response.value))
            ft.set_result(roles)
            result.clear_callbacks()

        def on_err(_, excls, excval, __):
            err = excls(excval)
            ft.set_exception(err)
            result.clear_callbacks()

        result.set_callbacks(on_ok, on_err)
        return ft

    def get_group(self,         # type: "AUserManager"
                  group_name,   # type: str
                  *options,     # type: GetGroupOptions
                  **kwargs      # type: Any
                  ):
        # type: (...) -> Group
        """
        Gets a group.

        :param str group_name: name of the group to get.
        :param options: GetRolesOptions
        :param Any kwargs: override corresponding values in the options.

        :return: An instance of Group.

        :raises: GroupNotFoundException
        :raises: InvalidArgumentsException
        Any exceptions raised by the underlying platform
        """

        final_args = forward_args(kwargs, *options)
        timeout = final_args.get("timeout", None)

        path = '/settings/rbac/groups/{}'.format(group_name)
        result = self._admin_bucket.http_request(path=path,
                                                 method='GET',
                                                 timeout=timeout)

        ft = asyncio.Future()

        def on_ok(response):
            ft.set_result(Group.load_from_server(response.value))
            result.clear_callbacks()

        def on_err(_, excls, excval, __):
            err = excls(excval)
            ft.set_exception(err)
            result.clear_callbacks()

        result.set_callbacks(on_ok, on_err)
        return ft

    def get_all_groups(self,         # type: "AUserManager"
                       *options,    # type: GetAllGroupsOptions
                       **kwargs     # type: Any
                       ):
        # type: (...) -> Iterable[Group]
        """
        Get all groups.

        :param timedelta timeout: the time allowed for the operation to be terminated. This is controlled by the client.

        :returns: An iterable collection of Group.
        """

        final_args = forward_args(kwargs, *options)
        timeout = final_args.get("timeout", None)
        result = self._admin_bucket.http_request(path='/settings/rbac/groups/',
                                                 method='GET',
                                                 timeout=timeout)
        ft = asyncio.Future()

        def on_ok(response):
            groups = list(
                map(lambda g: Group.load_from_server(g), response.value))
            ft.set_result(groups)
            result.clear_callbacks()

        def on_err(_, excls, excval, __):
            err = excls(excval)
            ft.set_exception(err)
            result.clear_callbacks()

        result.set_callbacks(on_ok, on_err)
        return ft

    def upsert_group(self,      # type: "AUserManager"
                     group,     # type: Group
                     *options,  # type: UpsertGroupOptions
                     **kwargs   # type: Any
                     ):
        """
        Creates or updates a group.

        :param Group group: the new version of the group.
        :param options: UpsertGroupOptions
        :param Any kwargs: override corresponding values in the options.

        :raises: InvalidArgumentsException
        Any exceptions raised by the underlying platform
        """
        # This endpoint accepts application/x-www-form-urlencoded and requires the data be sent as form data.
        # The name/id should not be included in the form data.
        # Roles should be a comma separated list of strings.
        # If, only if, the role contains a bucket name then the rolename should be suffixed
        # with[<bucket_name>] e.g. bucket_full_access[default],security_admin.

        final_args = forward_args(kwargs, *options)
        final_args.update({k: v for k, v in group.as_dict.items() if k in {
                          'roles', 'description', 'ldap_group_reference'}})
        params = {}
        roles = final_args.get("roles", None)
        if roles:
            params['roles'] = ','.join(
                list(map(lambda r: r.to_server_str(), roles)))

        description = final_args.get("description", None)
        if description:
            params['description'] = description

        ldap_group_reference = final_args.get("ldap_group_reference", None)
        if ldap_group_reference:
            params['ldap_group_ref'] = ldap_group_reference

        path = "/settings/rbac/groups/{}".format(group.name)
        form = mk_formstr(params)
        result = self._admin_bucket.http_request(path=path,
                                                 method='PUT',
                                                 content_type='application/x-www-form-urlencoded',
                                                 content=form,
                                                 timeout=final_args.get("timeout", None))

        ft = asyncio.Future()

        def on_ok(response):
            ft.set_result(response.value)
            result.clear_callbacks()

        def on_err(_, excls, excval, __):
            err = excls(excval)
            ft.set_exception(err)
            result.clear_callbacks()

        result.set_callbacks(on_ok, on_err)
        return ft

    def drop_group(self,        # type: "AUserManager"
                   group_name,  # type: str
                   *options,    # type: DropGroupOptions
                   **kwargs     # type: Any
                   ):
        """
        Removes a group.

        :param str group_name: name of the group.
        :param options: DropGroupOptions
        :param Any kwargs: override corresponding values in the options.

        :raises: GroupNotFoundException
        :raises: InvalidArgumentsException
        """
        result = self._admin_bucket.http_request("/settings/rbac/groups/{}".format(group_name), method='DELETE',
                                                 **forward_args(kwargs, *options))

        ft = asyncio.Future()

        def on_ok(response):
            ft.set_result(response.value)
            result.clear_callbacks()

        def on_err(_, excls, excval, __):
            err = excls(excval)
            ft.set_exception(err)
            result.clear_callbacks()

        result.set_callbacks(on_ok, on_err)
        return ft
