{"version":3,"file":"lib_index_js.c86e055e8ccff1c4543c.js","mappings":";;;;;;;;;;;;;;;AAA+B;AACxB;AACP,YAAY,gDAAmB;AAC/B,QAAQ,gDAAmB;AAC3B;AACA;AACA,QAAQ,gDAAmB;AAC3B;AACA;AACA,QAAQ,gDAAmB;AAC3B,QAAQ,gDAAmB;AAC3B,YAAY,gDAAmB;AAC/B,YAAY,gDAAmB;AAC/B,QAAQ,gDAAmB;AAC3B;;;;;;;;;;;;;;;;;;ACd+B;AACxB;AACP,YAAY,gDAAmB;AAC/B;AACA,QAAQ,gDAAmB;AAC3B;AACA,QAAQ,gDAAmB;AAC3B;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,gDAAmB;AAC/B;AACA,QAAQ,gDAAmB;AAC3B;AACA,QAAQ,gDAAmB;AAC3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClB4B;AACmC;AACsB;AAC7B;AACP;AACS;AACA;AACE;AACZ;AACZ;AACa;AACL;AACE;AAC9C;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,sEAAgC;AAC5F;AACA;AACA,kBAAkB,oEAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB,oEAAa;AAC/B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAc;AACjD,qBAAqB,6CAAO;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iCAAiC,iDAAY;AAC7C,4BAA4B,0DAAgB;AAC5C;AACA,4BAA4B,uEAAsB;AAClD,yBAAyB,iEAAgB;AACzC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAkB;AACnD;AACA,gBAAgB,gEAAU;AAC1B,qDAAqD,sBAAsB;AAC3E,0BAA0B,+DAAqB;AAC/C,iBAAiB;AACjB;AACA;AACA,gBAAgB,sEAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAU;AAC1B,uDAAuD,UAAU;AACjE,0BAA0B,+DAAqB;AAC/C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yEAAgB,EAAE,iEAAe,EAAE,kEAAc;AAChE,eAAe,2DAAS,EAAE,oEAAgB;AAC1C;AACA;AACA;AACA,oCAAoC,wDAAe;AACnD;AACA,qDAAqD;AACrD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;;ACjO0B;AACI;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAY,CAAC,kEAAe;AACxC;AACA,YAAY,+DAAY,CAAC,kEAAe;AACxC;AACA;AACA,iDAAiD,KAAK;AACtD;AACA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA,sDAAsD,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6DAAoB;AACrD;AACA;AACA;AACA,6CAA6C,YAAY,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gCAAgC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClI6D;AACI;AACN;AACI;AACA;AACF;AACJ;AACI;AACF;AACI;AACE;AACA;AACM;AACI;AACV;AACF;AACE;AACJ;AACF;AACI;AACJ;AACY;AACZ;AACI;AACA;AACsB;AAC1B;AACU;AACI;AACJ;AACZ;AACI;AACF;AACV;AACQ;AACQ;AACI;AAChB;AACI;AACN;AACE;AACF;AACI;AACJ;AACA;AACE;AACE;AACF;AACE;AACN;AACnB;AACQ;AAChC;AACP,6BAA6B,kDAAoB;AACjD,+BAA+B,oDAAsB;AACrD,4BAA4B,iDAAmB;AAC/C,8BAA8B,mDAAqB;AACnD,8BAA8B,mDAAqB;AACnD,6BAA6B,kDAAoB;AACjD,2BAA2B,gDAAkB;AAC7C,6BAA6B,kDAAoB;AACjD,4BAA4B,iDAAmB;AAC/C,8BAA8B,mDAAqB;AACnD,+BAA+B,qDAAsB;AACrD,+BAA+B,qDAAsB;AACrD,kCAAkC,wDAAyB;AAC3D,oCAAoC,0DAA2B;AAC/D,+BAA+B,qDAAsB;AACrD,8BAA8B,oDAAqB;AACnD,+BAA+B,qDAAsB;AACrD,6BAA6B,mDAAoB;AACjD,4BAA4B,kDAAmB;AAC/C,8BAA8B,oDAAqB;AACnD,4BAA4B,kDAAmB;AAC/C,kCAAkC,wDAAyB;AAC3D,4BAA4B,kDAAmB;AAC/C,8BAA8B,oDAAqB;AACnD,8BAA8B,oDAAqB;AACnD,yCAAyC,+DAAgC;AACzE,4BAA4B,kDAAmB;AAC/C,iCAAiC,uDAAwB;AACzD,mCAAmC,yDAA0B;AAC7D,iCAAiC,uDAAwB;AACzD,2BAA2B,iDAAkB;AAC7C,6BAA6B,mDAAoB;AACjD,4BAA4B,kDAAmB;AAC/C,uBAAuB,6CAAc;AACrC,2BAA2B,iDAAkB;AAC7C,+BAA+B,qDAAsB;AACrD,iCAAiC,uDAAwB;AACzD,yBAAyB,+CAAgB;AACzC,2BAA2B,iDAAkB;AAC7C,wBAAwB,8CAAe;AACvC,yBAAyB,+CAAgB;AACzC,wBAAwB,8CAAe;AACvC,0BAA0B,gDAAiB;AAC3C,wBAAwB,8CAAe;AACvC,wBAAwB,8CAAe;AACvC,yBAAyB,+CAAgB;AACzC,0BAA0B,gDAAiB;AAC3C,yBAAyB,+CAAgB;AACzC,0BAA0B,gDAAiB;AAC3C,uBAAuB,6CAAc;AACrC,WAAW,mCAAK;AAChB,iBAAiB,uCAAS;AAC1B;;;;;;;;;;;;;;;;;ACzGA;AACgF;AAChF;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA,oCAAoC,qFAAe;AACnD;AACA;;;;;;;;;;;;;;;;;;;;;ACvC0D;AACb;AACG;AACG;AACnD;AACA,WAAW,gEAAU;AACrB,gDAAgD,cAAc;AAC9D,cAAc,0DAAiB;AAC/B,KAAK;AACL;AACA;AACA,2BAA2B,gEAAU;AACrC;AACA,cAAc,gEAAsB;AACpC;AACA,YAAY,iEAAe;AAC3B;AACA,aAAa;AACb,YAAY,qEAAmB;AAC/B;AACA,aAAa;AACb,YAAY,mEAAiB;AAC7B;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO,GAAG,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,OAAO;AACxE;AACA;AACA,iEAAiE,OAAO;AACxE;AACA;AACA;AACA,iEAAiE,OAAO;AACxE;AACA,qBAAqB,kEAAe;AACpC;AACA,YAAY,+DAAY;AACxB,YAAY,+DAAY;AACxB;AACA;AACA,gCAAgC,+DAAY;AAC5C;AACA;AACA,gEAAgE,kEAAe;AAC/E;AACA;AACA;AACA,wCAAwC,QAAQ,KAAK,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;;;;;;;;;;;;;;;;;;ACjL4B;AACrB;AACP;AACA;AACA,YAAY,uEAAwB;AACpC,QAAQ,iEAAkB;AAC1B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAkB;AACzC,2DAA2D,oCAAoC,QAAQ,uEAAsB,EAAE;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAA2B;AAClD;AACA,oBAAoB,iFAAkC,4BAA4B,uFAAwC;AAC1H,wBAAwB,mFAAoC,CAAC,0EAA2B,qEAAqE,uFAAwC;AACrM,uBAAuB,mEAAkB;AACzC;AACA;AACA;AACA,oBAAoB,+EAAgC,CAAC,0EAA2B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kEAAmB;AACvC;AACA,wBAAwB,8DAAe;AACvC,+BAA+B,+EAAgC;AAC/D;AACA;AACA,uBAAuB,gEAAiB;AACxC;AACA,6BAA6B,2DAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAqB;AACzC;AACA;AACA,oDAAoD,6EAA4B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gEAAiB;AACxC;AACA;AACA,mCAAmC,2DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@jupyterlab/plugin-playground/./lib/dialogs.js","webpack://@jupyterlab/plugin-playground/./lib/errors.js","webpack://@jupyterlab/plugin-playground/./lib/index.js","webpack://@jupyterlab/plugin-playground/./lib/loader.js","webpack://@jupyterlab/plugin-playground/./lib/modules.js","webpack://@jupyterlab/plugin-playground/./lib/requirejs.js","webpack://@jupyterlab/plugin-playground/./lib/resolver.js","webpack://@jupyterlab/plugin-playground/./lib/transpiler.js"],"sourcesContent":["import * as React from 'react';\nexport function formatCDNConsentDialog(moduleName, url) {\n    return (React.createElement(\"div\", null,\n        React.createElement(\"p\", null,\n            moduleName,\n            \" is not a part of the distribution and needs to be downloaded before execution.\"),\n        React.createElement(\"p\", null,\n            \"The current CDN URL is: \",\n            url),\n        React.createElement(\"p\", null, \"You should only allow to execute code from CDN if:\"),\n        React.createElement(\"ul\", null,\n            React.createElement(\"li\", null, \"you fully trust the CDN provider AND your internet service provider AND your network administrator AND their ability to immediately remedy any attack against the network, or\"),\n            React.createElement(\"li\", null, \"you verified the integrity of the package by defining a cryptographic hash for verification via SRI feature [support to be implemented]\")),\n        React.createElement(\"p\", null, \"You can abort execution and change the CDN URL in the settings first.\")));\n}\n","import * as React from 'react';\nexport function formatErrorWithResult(error, result) {\n    return (React.createElement(\"div\", null,\n        \"Error:\",\n        React.createElement(\"pre\", null, error.stack ? error.stack : error.message),\n        \"Final code:\",\n        React.createElement(\"pre\", null, result.code),\n        result.transpiled\n            ? 'The code was transpiled'\n            : 'The code was not transpiled',\n        \".\"));\n}\nexport function formatImportError(error, module) {\n    return (React.createElement(\"div\", null,\n        \"Error when importing \",\n        React.createElement(\"code\", null, module),\n        \":\",\n        React.createElement(\"pre\", null, error.stack ? error.stack : error.message)));\n}\n","import ts from 'typescript';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { showDialog, showErrorMessage, ICommandPalette } from '@jupyterlab/apputils';\nimport { IEditorTracker } from '@jupyterlab/fileeditor';\nimport { ILauncher } from '@jupyterlab/launcher';\nimport { extensionIcon } from '@jupyterlab/ui-components';\nimport { IDocumentManager } from '@jupyterlab/docmanager';\nimport { PluginLoader, PluginLoadingError } from './loader';\nimport { PluginTranspiler } from './transpiler';\nimport { modules } from './modules';\nimport { formatErrorWithResult } from './errors';\nimport { ImportResolver } from './resolver';\nimport { RequireJSLoader } from './requirejs';\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.createNewFile = 'plugin-playground:create-new-plugin';\n    CommandIDs.loadCurrentAsExtension = 'plugin-playground:load-as-extension';\n})(CommandIDs || (CommandIDs = {}));\nconst PLUGIN_TEMPLATE = `import {\n  JupyterFrontEnd,\n  JupyterFrontEndPlugin,\n} from '@jupyterlab/application';\n\n/**\n * This is an example hello world plugin.\n * Open Command Palette with Ctrl+Shift+C\n * (Command+Shift+C on Mac) and select\n * \"Load Current File as Extension\"\n */\nconst plugin: JupyterFrontEndPlugin<void> = {\n  id: 'hello-world:plugin',\n  autoStart: true,\n  activate: (app: JupyterFrontEnd) => {\n    alert('Hello World!');\n  },\n};\n\nexport default plugin;\n`;\nclass PluginPlayground {\n    constructor(app, settingRegistry, commandPalette, editorTracker, launcher, documentManager, settings, requirejs) {\n        this.app = app;\n        this.settingRegistry = settingRegistry;\n        this.documentManager = documentManager;\n        this.settings = settings;\n        this.requirejs = requirejs;\n        // Define the widgets base module for RequireJS (left for compatibility only)\n        requirejs.define('@jupyter-widgets/base', [], () => modules['@jupyter-widgets/base']);\n        app.commands.addCommand(CommandIDs.loadCurrentAsExtension, {\n            label: 'Load Current File As Extension',\n            icon: extensionIcon,\n            isEnabled: () => editorTracker.currentWidget !== null &&\n                editorTracker.currentWidget === app.shell.currentWidget,\n            execute: async () => {\n                const currentWidget = editorTracker.currentWidget;\n                if (currentWidget) {\n                    const currentText = currentWidget.context.model.toString();\n                    this._loadPlugin(currentText, currentWidget.context.path);\n                }\n            }\n        });\n        commandPalette.addItem({\n            command: CommandIDs.loadCurrentAsExtension,\n            category: 'Plugin Playground',\n            args: {}\n        });\n        app.commands.addCommand(CommandIDs.createNewFile, {\n            label: 'TypeScript File (Playground)',\n            caption: 'Create a new TypeScript file',\n            icon: extensionIcon,\n            execute: async (args) => {\n                const model = await app.commands.execute('docmanager:new-untitled', {\n                    path: args['cwd'],\n                    type: 'file',\n                    ext: 'ts'\n                });\n                const widget = await app.commands.execute('docmanager:open', {\n                    path: model.path,\n                    factory: 'Editor'\n                });\n                if (widget) {\n                    widget.content.ready.then(() => {\n                        widget.content.model.value.text = PLUGIN_TEMPLATE;\n                    });\n                }\n                return widget;\n            }\n        });\n        app.restored.then(async () => {\n            const settings = this.settings;\n            this._updateSettings(requirejs, settings);\n            // add to the launcher\n            if (launcher && settings.composite.showIconInLauncher) {\n                launcher.add({\n                    command: CommandIDs.createNewFile,\n                    category: 'Other',\n                    rank: 1\n                });\n            }\n            const urls = settings.composite.urls;\n            for (const u of urls) {\n                await this._getModule(u);\n            }\n            const plugins = settings.composite.plugins;\n            for (const t of plugins) {\n                await this._loadPlugin(t, null);\n            }\n            settings.changed.connect(updatedSettings => {\n                this._updateSettings(requirejs, updatedSettings);\n            });\n        });\n    }\n    _updateSettings(requirejs, settings) {\n        const baseURL = settings.composite.requirejsCDN;\n        requirejs.require.config({\n            baseUrl: baseURL\n        });\n    }\n    async _loadPlugin(code, path) {\n        const tokenMap = new Map(Array.from(this.app._serviceMap.keys()).map((t) => [\n            t.name,\n            t\n        ]));\n        // Widget registry does not follow convention of importName:tokenName\n        tokenMap.set('@jupyter-widgets/base:IJupyterWidgetRegistry', tokenMap.get('jupyter.extensions.jupyterWidgetRegistry'));\n        const importResolver = new ImportResolver({\n            modules: modules,\n            tokenMap: tokenMap,\n            requirejs: this.requirejs,\n            settings: this.settings,\n            serviceManager: this.app.serviceManager,\n            basePath: path\n        });\n        const pluginLoader = new PluginLoader({\n            transpiler: new PluginTranspiler({\n                compilerOptions: {\n                    target: ts.ScriptTarget.ES2017,\n                    jsx: ts.JsxEmit.React\n                }\n            }),\n            importFunction: importResolver.resolve.bind(importResolver),\n            tokenMap: tokenMap,\n            serviceManager: this.app.serviceManager,\n            requirejs: this.requirejs\n        });\n        importResolver.dynamicLoader = pluginLoader.loadFile.bind(pluginLoader);\n        let result;\n        try {\n            result = await pluginLoader.load(code, path);\n        }\n        catch (error) {\n            if (error instanceof PluginLoadingError) {\n                const internalError = error.error;\n                showDialog({\n                    title: `Plugin loading failed: ${internalError.message}`,\n                    body: formatErrorWithResult(error, error.partialResult)\n                });\n            }\n            else {\n                showErrorMessage('Plugin loading failed', error.message);\n            }\n            return;\n        }\n        const plugin = result.plugin;\n        if (result.schema) {\n            // TODO: this is mostly fine to get the menus and toolbars, but:\n            // - transforms are not applied\n            // - any refresh from the server might overwrite the data\n            // - it is not a good long term solution in general\n            this.settingRegistry.plugins[plugin.id] = {\n                id: plugin.id,\n                schema: JSON.parse(result.schema),\n                raw: result.schema,\n                data: {\n                    composite: {},\n                    user: {}\n                },\n                version: '0.0.0'\n            };\n            this.settingRegistry.pluginChanged.emit(plugin.id);\n        }\n        // Unregister plugin if already registered.\n        if (this.app.hasPlugin(plugin.id)) {\n            delete this.app._pluginMap[plugin.id];\n        }\n        this.app.registerPluginModule(plugin);\n        if (plugin.autoStart) {\n            try {\n                await this.app.activatePlugin(plugin.id);\n            }\n            catch (e) {\n                showDialog({\n                    title: `Plugin autostart failed: ${e.message}`,\n                    body: formatErrorWithResult(e, result)\n                });\n                return;\n            }\n        }\n    }\n    async _getModule(url) {\n        const response = await fetch(url);\n        const jsBody = await response.text();\n        this._loadPlugin(jsBody, null);\n    }\n}\n/**\n * Initialization data for the @jupyterlab/plugin-playground extension.\n */\nconst plugin = {\n    id: '@jupyterlab/plugin-playground:plugin',\n    autoStart: true,\n    requires: [ISettingRegistry, ICommandPalette, IEditorTracker],\n    optional: [ILauncher, IDocumentManager],\n    activate: (app, settingRegistry, commandPalette, editorTracker, launcher, documentManager) => {\n        // In order to accommodate loading ipywidgets and other AMD modules, we\n        // load RequireJS before loading any custom extensions.\n        const requirejsLoader = new RequireJSLoader();\n        // We coud convert to `async` and use `await` but we don't, because a failure\n        // would freeze JupyterLab on splash screen; this way if it fails to load,\n        // only the plugin is affected, not the entire application.\n        Promise.all([settingRegistry.load(plugin.id), requirejsLoader.load()]).then(([settings, requirejs]) => {\n            new PluginPlayground(app, settingRegistry, commandPalette, editorTracker, launcher, documentManager, settings, requirejs);\n        });\n    }\n};\nexport default plugin;\n","import { PathExt } from '@jupyterlab/coreutils';\nimport { NoDefaultExportError } from './transpiler';\nexport class PluginLoader {\n    constructor(options) {\n        this._options = options;\n    }\n    async loadFile(code) {\n        const functionBody = this._options.transpiler.transpile(code, false);\n        return await this._createAsyncFunctionModule(functionBody);\n    }\n    async _createAsyncFunctionModule(transpiledCode) {\n        const module = new AsyncFunction(this._options.transpiler.importFunctionName, transpiledCode);\n        return await module(this._options.importFunction);\n    }\n    async _discoverSchema(pluginPath) {\n        if (!pluginPath) {\n            console.warn('Not looking for schema: no path');\n            return null;\n        }\n        const serviceManager = this._options.serviceManager;\n        if (!serviceManager) {\n            console.warn('Not looking for schema: no document manager');\n            return null;\n        }\n        const candidatePaths = [\n            // canonical\n            PathExt.join(PathExt.dirname(pluginPath), '..', 'schema', 'plugin.json'),\n            // simplification for dynamic plugins\n            PathExt.join(PathExt.dirname(pluginPath), 'plugin.json')\n        ];\n        for (const path of candidatePaths) {\n            console.log(`Looking for schema in ${path}`);\n            try {\n                const file = await serviceManager.contents.get(path);\n                console.log(`Found schema in ${path}`);\n                return file.content;\n            }\n            catch (e) {\n                console.log(`Did not find schema in ${path}`);\n            }\n        }\n        return null;\n    }\n    /**\n     * Create a plugin from TypeScript code.\n     */\n    async load(code, basePath) {\n        var _a, _b;\n        let functionBody;\n        let plugin;\n        let transpiled = true;\n        try {\n            functionBody = this._options.transpiler.transpile(code, true);\n        }\n        catch (error) {\n            if (error instanceof NoDefaultExportError) {\n                // no export statment\n                // for compatibility with older version\n                console.log('No default export was found in the plugin code, falling back to object-based evaluation');\n                functionBody = `'use strict';\\nreturn (${code})`;\n                transpiled = false;\n            }\n            else {\n                throw error;\n            }\n        }\n        console.log(functionBody);\n        let schema = null;\n        try {\n            if (transpiled) {\n                const module = await this._createAsyncFunctionModule(functionBody);\n                plugin = module.default;\n                schema = await this._discoverSchema(basePath);\n            }\n            else {\n                const requirejs = this._options.requirejs;\n                plugin = new Function('require', 'requirejs', 'define', functionBody)(requirejs.require, requirejs.require, requirejs.define);\n            }\n        }\n        catch (e) {\n            throw new PluginLoadingError(e, { code: functionBody, transpiled });\n        }\n        // We allow one level of indirection (return a function instead of a plugin)\n        if (typeof plugin === 'function') {\n            plugin = plugin();\n        }\n        // Finally, we allow returning a promise (or an async function above).\n        plugin = (await Promise.resolve(plugin));\n        plugin.requires = (_a = plugin.requires) === null || _a === void 0 ? void 0 : _a.map((value) => {\n            if (!isString(value)) {\n                // already a token\n                return value;\n            }\n            const token = this._options.tokenMap.get(value);\n            if (!token) {\n                throw Error('Required token' + value + 'not found in the token map');\n            }\n            return token;\n        });\n        plugin.optional = (_b = plugin.optional) === null || _b === void 0 ? void 0 : _b.map((value) => {\n            if (!isString(value)) {\n                // already a token\n                return value;\n            }\n            const token = this._options.tokenMap.get(value);\n            if (!token) {\n                console.log('Optional token' + value + 'not found in the token map');\n            }\n            return token;\n        }).filter((token) => token != null);\n        return {\n            schema,\n            plugin,\n            code: functionBody,\n            transpiled\n        };\n    }\n}\nfunction isString(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexport class PluginLoadingError extends Error {\n    constructor(error, partialResult) {\n        super();\n        this.error = error;\n        this.partialResult = partialResult;\n    }\n}\nconst AsyncFunction = Object.getPrototypeOf(async () => {\n    // no-op\n}).constructor;\n","import * as jupyter_widgets_base from '@jupyter-widgets/base';\nimport * as jupyterlab_application from '@jupyterlab/application';\nimport * as jupyterlab_apputils from '@jupyterlab/apputils';\nimport * as jupyterlab_codeeditor from '@jupyterlab/codeeditor';\nimport * as jupyterlab_codemirror from '@jupyterlab/codemirror';\nimport * as jupyterlab_completer from '@jupyterlab/completer';\nimport * as jupyterlab_console from '@jupyterlab/console';\nimport * as jupyterlab_coreutils from '@jupyterlab/coreutils';\nimport * as jupyterlab_debugger from '@jupyterlab/debugger';\nimport * as jupyterlab_docmanager from '@jupyterlab/docmanager';\nimport * as jupyterlab_docprovider from '@jupyterlab/docprovider';\nimport * as jupyterlab_docregistry from '@jupyterlab/docregistry';\nimport * as jupyterlab_documentsearch from '@jupyterlab/documentsearch';\nimport * as jupyterlab_extensionmanager from '@jupyterlab/extensionmanager';\nimport * as jupyterlab_filebrowser from '@jupyterlab/filebrowser';\nimport * as jupyterlab_fileeditor from '@jupyterlab/fileeditor';\nimport * as jupyterlab_imageviewer from '@jupyterlab/imageviewer';\nimport * as jupyterlab_inspector from '@jupyterlab/inspector';\nimport * as jupyterlab_launcher from '@jupyterlab/launcher';\nimport * as jupyterlab_logconsole from '@jupyterlab/logconsole';\nimport * as jupyterlab_mainmenu from '@jupyterlab/mainmenu';\nimport * as jupyterlab_markdownviewer from '@jupyterlab/markdownviewer';\nimport * as jupyterlab_notebook from '@jupyterlab/notebook';\nimport * as jupyterlab_outputarea from '@jupyterlab/outputarea';\nimport * as jupyterlab_rendermime from '@jupyterlab/rendermime';\nimport * as jupyterlab_rendermime_interfaces from '@jupyterlab/rendermime-interfaces';\nimport * as jupyterlab_services from '@jupyterlab/services';\nimport * as jupyterlab_settingeditor from '@jupyterlab/settingeditor';\nimport * as jupyterlab_settingregistry from '@jupyterlab/settingregistry';\nimport * as jupyterlab_shared_models from '@jupyterlab/shared-models';\nimport * as jupyterlab_statedb from '@jupyterlab/statedb';\nimport * as jupyterlab_statusbar from '@jupyterlab/statusbar';\nimport * as jupyterlab_terminal from '@jupyterlab/terminal';\nimport * as jupyterlab_toc from '@jupyterlab/toc';\nimport * as jupyterlab_tooltip from '@jupyterlab/tooltip';\nimport * as jupyterlab_translation from '@jupyterlab/translation';\nimport * as jupyterlab_ui_components from '@jupyterlab/ui-components';\nimport * as lumino_algorithm from '@lumino/algorithm';\nimport * as lumino_application from '@lumino/application';\nimport * as lumino_commands from '@lumino/commands';\nimport * as lumino_coreutils from '@lumino/coreutils';\nimport * as lumino_datagrid from '@lumino/datagrid';\nimport * as lumino_disposable from '@lumino/disposable';\nimport * as lumino_domutils from '@lumino/domutils';\nimport * as lumino_dragdrop from '@lumino/dragdrop';\nimport * as lumino_messaging from '@lumino/messaging';\nimport * as lumino_properties from '@lumino/properties';\nimport * as lumino_signaling from '@lumino/signaling';\nimport * as lumino_virtualdom from '@lumino/virtualdom';\nimport * as lumino_widgets from '@lumino/widgets';\nimport * as react from 'react';\nimport * as react_dom from 'react-dom';\nexport const modules = {\n    '@jupyter-widgets/base': jupyter_widgets_base,\n    '@jupyterlab/application': jupyterlab_application,\n    '@jupyterlab/apputils': jupyterlab_apputils,\n    '@jupyterlab/codeeditor': jupyterlab_codeeditor,\n    '@jupyterlab/codemirror': jupyterlab_codemirror,\n    '@jupyterlab/completer': jupyterlab_completer,\n    '@jupyterlab/console': jupyterlab_console,\n    '@jupyterlab/coreutils': jupyterlab_coreutils,\n    '@jupyterlab/debugger': jupyterlab_debugger,\n    '@jupyterlab/docmanager': jupyterlab_docmanager,\n    '@jupyterlab/docprovider': jupyterlab_docprovider,\n    '@jupyterlab/docregistry': jupyterlab_docregistry,\n    '@jupyterlab/documentsearch': jupyterlab_documentsearch,\n    '@jupyterlab/extensionmanager': jupyterlab_extensionmanager,\n    '@jupyterlab/filebrowser': jupyterlab_filebrowser,\n    '@jupyterlab/fileeditor': jupyterlab_fileeditor,\n    '@jupyterlab/imageviewer': jupyterlab_imageviewer,\n    '@jupyterlab/inspector': jupyterlab_inspector,\n    '@jupyterlab/launcher': jupyterlab_launcher,\n    '@jupyterlab/logconsole': jupyterlab_logconsole,\n    '@jupyterlab/mainmenu': jupyterlab_mainmenu,\n    '@jupyterlab/markdownviewer': jupyterlab_markdownviewer,\n    '@jupyterlab/notebook': jupyterlab_notebook,\n    '@jupyterlab/outputarea': jupyterlab_outputarea,\n    '@jupyterlab/rendermime': jupyterlab_rendermime,\n    '@jupyterlab/rendermime-interfaces': jupyterlab_rendermime_interfaces,\n    '@jupyterlab/services': jupyterlab_services,\n    '@jupyterlab/settingeditor': jupyterlab_settingeditor,\n    '@jupyterlab/settingregistry': jupyterlab_settingregistry,\n    '@jupyterlab/shared-models': jupyterlab_shared_models,\n    '@jupyterlab/statedb': jupyterlab_statedb,\n    '@jupyterlab/statusbar': jupyterlab_statusbar,\n    '@jupyterlab/terminal': jupyterlab_terminal,\n    '@jupyterlab/toc': jupyterlab_toc,\n    '@jupyterlab/tooltip': jupyterlab_tooltip,\n    '@jupyterlab/translation': jupyterlab_translation,\n    '@jupyterlab/ui-components': jupyterlab_ui_components,\n    '@lumino/algorithm': lumino_algorithm,\n    '@lumino/application': lumino_application,\n    '@lumino/commands': lumino_commands,\n    '@lumino/coreutils': lumino_coreutils,\n    '@lumino/datagrid': lumino_datagrid,\n    '@lumino/disposable': lumino_disposable,\n    '@lumino/domutils': lumino_domutils,\n    '@lumino/dragdrop': lumino_dragdrop,\n    '@lumino/messaging': lumino_messaging,\n    '@lumino/properties': lumino_properties,\n    '@lumino/signaling': lumino_signaling,\n    '@lumino/virtualdom': lumino_virtualdom,\n    '@lumino/widgets': lumino_widgets,\n    react: react,\n    'react-dom': react_dom\n};\n","/// <reference types=\"requirejs\" />\nimport requireJsSource from '!!raw-loader!../node_modules/requirejs/require.js';\n/**\n * Load requirejs in an iframe to avoid polution of `window` object.\n */\nexport async function loadInIsolated(source) {\n    return new Promise((resolve, reject) => {\n        const iframe = document.createElement('iframe');\n        iframe.style.display = 'none';\n        iframe.onload = () => {\n            const contentWindow = iframe.contentWindow;\n            if (!contentWindow) {\n                reject('Cannot load in isolated: no contentWindow, origin error?');\n                return;\n            }\n            const iframeWindow = contentWindow.window;\n            // execure require JS\n            iframeWindow.eval(source);\n            const requirejs = {\n                require: iframeWindow.require,\n                define: iframeWindow.define\n            };\n            if (requirejs.require && requirejs.define) {\n                resolve(requirejs);\n            }\n            else {\n                reject('Require.js loading did not result in `require` and `define` objects attachment to window');\n            }\n            // Note: cannot remove child from parent node, or require.js will not work\n            // because it's timer will not be able to tick (no window reference)!\n            iframe.onload = null;\n        };\n        document.body.appendChild(iframe);\n    });\n}\nexport class RequireJSLoader {\n    async load() {\n        return await loadInIsolated(requireJsSource);\n    }\n}\n","import { Dialog, showDialog } from '@jupyterlab/apputils';\nimport { formatImportError } from './errors';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { formatCDNConsentDialog } from './dialogs';\nfunction handleImportError(error, module) {\n    return showDialog({\n        title: `Import in plugin code failed: ${error.message}`,\n        body: formatImportError(error, module)\n    });\n}\nasync function askUserForCDNPolicy(exampleModule, cdnUrl) {\n    const decision = await showDialog({\n        title: 'Allow execution of code from CDN?',\n        body: formatCDNConsentDialog(exampleModule, cdnUrl),\n        buttons: [\n            Dialog.okButton({\n                label: 'Forbid'\n            }),\n            Dialog.cancelButton({\n                label: 'Abort'\n            }),\n            Dialog.warnButton({\n                label: 'Allow'\n            })\n        ],\n        defaultButton: 0\n    });\n    switch (decision.button.label) {\n        case 'Forbid':\n            return 'never';\n        case 'Allow':\n            return 'always-insecure';\n        case 'Abort':\n            return 'abort-to-investigate';\n        default:\n            return 'awaiting-decision';\n    }\n}\nexport class ImportResolver {\n    constructor(_options) {\n        this._options = _options;\n        // no-op\n    }\n    set dynamicLoader(loader) {\n        this._options.dynamicLoader = loader;\n    }\n    /**\n     * Convert import to:\n     *   - token string,\n     *   - module assignment if appropriate module is available,\n     *   - requirejs import if everything else fails\n     */\n    async resolve(module) {\n        try {\n            const tokenAndDefaultHandler = {\n                get: (target, prop, receiver) => {\n                    if (typeof prop !== 'string') {\n                        return Reflect.get(target, prop, receiver);\n                    }\n                    const tokenName = `${module}:${prop}`;\n                    if (this._options.tokenMap.has(tokenName)) {\n                        // eslint-disable-next-line  @typescript-eslint/no-non-null-assertion\n                        return this._options.tokenMap.get(tokenName);\n                    }\n                    // synthetic default import (without proxy)\n                    if (prop === 'default' && !(prop in target)) {\n                        return target;\n                    }\n                    return Reflect.get(target, prop, receiver);\n                }\n            };\n            const knownModule = this._resolveKnownModule(module);\n            if (knownModule !== null) {\n                return new Proxy(knownModule, tokenAndDefaultHandler);\n            }\n            const localFile = await this._resolveLocalFile(module);\n            if (localFile !== null) {\n                return localFile;\n            }\n            const baseURL = this._options.settings.composite.requirejsCDN;\n            const consent = await this._getCDNConsent(module, baseURL);\n            if (!consent.agreed) {\n                throw new Error(`Module ${module} requires execution from CDN but it is not allowed.`);\n            }\n            const externalAMDModule = await this._resolveAMDModule(module);\n            if (externalAMDModule !== null) {\n                return externalAMDModule;\n            }\n            throw new Error(`Could not resolve the module ${module}`);\n        }\n        catch (error) {\n            handleImportError(error, module);\n            throw error;\n        }\n    }\n    async _getCDNConsent(module, cdnUrl) {\n        const allowCDN = this._options.settings.composite.allowCDN;\n        switch (allowCDN) {\n            case 'awaiting-decision': {\n                const newPolicy = await askUserForCDNPolicy(module, cdnUrl);\n                if (newPolicy === 'abort-to-investigate') {\n                    throw new Error('User aborted execution when asked about CDN policy');\n                }\n                else {\n                    await this._options.settings.set('allowCDN', newPolicy);\n                }\n                return await this._getCDNConsent(module, cdnUrl);\n            }\n            case 'never':\n                console.warn('Not loading the module ', module, 'as it is not a known token/module and the CDN policy is set to `never`');\n                return { agreed: false };\n            case 'always-insecure':\n                return { agreed: true };\n        }\n    }\n    _resolveKnownModule(module) {\n        if (Object.prototype.hasOwnProperty.call(this._options.modules, module)) {\n            return this._options.modules[module];\n        }\n        return null;\n    }\n    async _resolveAMDModule(module) {\n        const require = this._options.requirejs.require;\n        return new Promise((resolve, reject) => {\n            console.log('Fetching', module, 'via require.js');\n            require([module], (mod) => {\n                if (!mod) {\n                    reject(`Module ${module} could not be loaded via require.js`);\n                }\n                return resolve(mod);\n            }, (error) => {\n                return reject(error);\n            });\n        });\n    }\n    async _resolveLocalFile(module) {\n        if (!module.startsWith('.')) {\n            // not a local file, can't help here\n            return null;\n        }\n        const serviceManager = this._options.serviceManager;\n        if (serviceManager === null) {\n            throw Error(`Cannot resolve import of local module ${module}: service manager is not available`);\n        }\n        if (!this._options.dynamicLoader) {\n            throw Error(`Cannot resolve import of local module ${module}: dynamic loader is not available`);\n        }\n        const path = this._options.basePath;\n        if (path === null) {\n            throw Error(`Cannot resolve import of local module ${module}: the base path was not provided`);\n        }\n        const base = PathExt.dirname(path);\n        const candidatePaths = [\n            PathExt.join(base, module + '.ts'),\n            PathExt.join(base, module + '.tsx')\n        ];\n        if (module.endsWith('.svg')) {\n            candidatePaths.push(PathExt.join(base, module));\n        }\n        for (const candidatePath of candidatePaths) {\n            const directory = await serviceManager.contents.get(PathExt.dirname(candidatePath));\n            const files = directory.content;\n            const filePaths = new Set(files.map(file => file.path));\n            if (filePaths.has(candidatePath)) {\n                console.log(`Resolved ${module} to ${candidatePath}`);\n                const file = await serviceManager.contents.get(candidatePath);\n                if (candidatePath.endsWith('.svg')) {\n                    return {\n                        default: file.content\n                    };\n                }\n                return await this._options.dynamicLoader(file.content);\n            }\n        }\n        console.warn(`Could not resolve ${module}, candidate paths:`, candidatePaths);\n        return null;\n    }\n}\n","import ts from 'typescript';\nexport class NoDefaultExportError extends Error {\n}\nfunction isUseStrict(node) {\n    return (ts.isExpressionStatement(node) &&\n        ts.isStringLiteral(node.expression) &&\n        node.expression.text === 'use strict');\n}\nexport class PluginTranspiler {\n    constructor(options) {\n        this.importFunctionName = 'require';\n        this._options = options;\n        if (options.compilerOptions.module) {\n            throw new Error('The module setting is an implementation detail of transpiler.');\n        }\n    }\n    /**\n     * Transpile an ES6 plugin into a function body of an async function,\n     * returning the plugin that would be exported as default.\n     */\n    transpile(code, requireDefaultExport) {\n        const result = ts.transpileModule(code, {\n            compilerOptions: Object.assign(Object.assign({}, this._options.compilerOptions), { module: ts.ModuleKind.CommonJS }),\n            transformers: {\n                before: requireDefaultExport\n                    ? [this._requireDefaultExportTransformer()]\n                    : [],\n                after: [\n                    this._awaitRequireTransformer(),\n                    this._exportWrapperTransformer()\n                ]\n            }\n        });\n        return result.outputText;\n    }\n    _exportWrapperTransformer() {\n        // working on output of `createImportCallExpressionCommonJS` from TypeScript\n        return context => {\n            return source => {\n                const transpiledStatements = [...source.statements];\n                const pinnedStatements = [];\n                if (isUseStrict(transpiledStatements[0])) {\n                    // eslint-disable-next-line  @typescript-eslint/no-non-null-assertion\n                    const first = transpiledStatements.shift();\n                    pinnedStatements.push(first);\n                }\n                return ts.factory.updateSourceFile(source, [\n                    ...pinnedStatements,\n                    ts.factory.createVariableStatement(undefined /* modifiers */, ts.factory.createVariableDeclarationList([\n                        ts.factory.createVariableDeclaration(ts.factory.createIdentifier('exports'), undefined /* exclamationToken */, undefined /* type */, ts.factory.createObjectLiteralExpression())\n                    ], ts.NodeFlags.Const)),\n                    // original statements\n                    ...transpiledStatements,\n                    // return `exports`\n                    ts.factory.createReturnStatement(ts.factory.createIdentifier('exports'))\n                ]);\n            };\n        };\n    }\n    _awaitRequireTransformer() {\n        // working on output of `createImportCallExpressionCommonJS` from TypeScript\n        return context => {\n            const visit = node => {\n                if (ts.isCallExpression(node)) {\n                    const expression = node.expression;\n                    if (ts.isIdentifier(expression) && expression.text === 'require') {\n                        return ts.factory.createAwaitExpression(node);\n                    }\n                }\n                return ts.visitEachChild(node, child => visit(child), context);\n            };\n            return source => ts.visitNode(source, visit);\n        };\n    }\n    _requireDefaultExportTransformer() {\n        return context => {\n            let defaultExport = null;\n            const visit = node => {\n                // default export\n                if (ts.isExportAssignment(node)) {\n                    const hasDefaultClause = node\n                        .getChildren()\n                        .some(node => node.kind === ts.SyntaxKind.DefaultKeyword);\n                    if (hasDefaultClause) {\n                        defaultExport = node.expression;\n                    }\n                    else {\n                        console.warn('Export assignment without default keyword not supported: ' +\n                            node.getText(), node);\n                    }\n                }\n                return ts.visitEachChild(node, child => visit(child), context);\n            };\n            return source => {\n                const traveresed = ts.visitNode(source, visit);\n                if (!defaultExport) {\n                    throw new NoDefaultExportError('Default export not found');\n                }\n                return traveresed;\n            };\n        };\n    }\n}\n"],"names":[],"sourceRoot":""}