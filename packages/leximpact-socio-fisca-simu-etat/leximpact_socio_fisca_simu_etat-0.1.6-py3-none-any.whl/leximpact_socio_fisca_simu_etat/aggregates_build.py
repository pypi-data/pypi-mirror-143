# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/aggregates_build.ipynb (unless otherwise specified).

__all__ = [
    "config",
    "tc",
    "agregats",
    "yaml",
    "get_aggregats_from_row_count",
    "libelles",
    "year",
    "counts",
    "liste_des_variables_csg_2018",
    "liste_des_variables_csg_2019",
    "pote",
    "get_aggregats_from_row",
    "get_aggregate_from_df",
    "nested_set",
    "prepare_actions",
    "Aggregate",
    "Simu",
    "Action",
    "Actions",
    "to_process",
    "get_factor",
    "process_actions",
    "save_agg",
]

# Cell

import unittest
from typing import List, Optional, Union

import numpy as np
import pandas as pd
from pydantic import BaseModel
from ruamel.yaml import YAML

from .config import Configuration
from .csg_simu import compute_reform
from .schema import ReformeSocioFiscale

config = Configuration(project_folder="leximpact-socio-fiscal-simu-etat")
tc = unittest.TestCase()

agregats = {}
yaml = YAML()  # typ='unsafe' for testing

# Cell

libelles = {
    "agec": "ANNÉE DE NAISSANCE CONJOINT".lower(),
    "aged": "ANNÉE DE NAISSANCE DÉCLARANT".lower(),
    "clirpg": "ENFANTS INVALIDES".lower(),
    "mat": "Situation matrimoniale",
    "n": "NOMBRE D'ENFANTS MARIÉS RATTACHÉS".lower(),
    "nbefi": "NB TOTAL ENFANT A CHARGE I".lower(),
    "nbfoy": "NB PERSONNES DANS LE FOYER".lower(),
    "nbpldm": "INDICATEUR MARIé".lower(),
}


def get_aggregats_from_row_count(row, var_name, year, source_database):
    """
    Parcours les lignes du dataframe et enregistre les agrégats dans le dictionnaire.
    ::row:: une ligne de dataframe
    ::year:: year of the data
    """
    global agregats
    if agregats.get(year) is None:
        agregats[year] = {}
    if agregats[year].get(var_name) is None:
        agregats[year][var_name] = {"ux_name": libelles[var_name]}
    if agregats[year][var_name].get(source_database) is None:
        agregats[year][var_name][source_database] = {
            "source": "https://www.casd.eu/source/declarations-dimpot-sur-le-revenu-des-foyers-fiscaux-formulaire-2042-et-annexes/",
            "values": {},
        }
    if row["count"] == row["count"]:
        val = row["count"]
        if isinstance(val, np.float64):
            val = float(val)
        # else:
        #     print(f"{val} : {type(val)}")
    else:
        val = "secret"
    name = row[var_name]
    if isinstance(name, np.float64):
        name = float(name)
    # else:
    #     print(f"{name} : {type(name)}")

    agregats[year][var_name][source_database]["values"][name] = val
    # agregats[year][var_name][source_database]["values"][str(row[var_name])] = str(val)


# Cell

year = "2019"
counts = ["clirpg", "mat", "n", "nbefi", "nbfoy", "nbpldm"]  # "agec", "aged",
for var_name in counts:
    df = pd.read_csv(
        f"{config.get('CALIB')}20220224_ExtractAgg/sorties/count_{year}_{var_name}.csv"
    )
    if var_name in ["agec", "aged"]:
        df.drop(df[df[var_name] == "0.0"].index, inplace=True)
    _ = df.apply(get_aggregats_from_row_count, args=[var_name, year, "POTE"], axis=1)

# Cell
pd.set_option("display.max_colwidth", 80)
pd.options.display.float_format = "{:,.7f}".format

liste_des_variables_csg_2018 = pd.read_csv(
    config.get("CALIB") + "agregats_des_variables_csg-POTE_2018.csv"
)
liste_des_variables_csg_2019 = pd.read_csv(
    config.get("CALIB") + "agregats_des_variables_csg-POTE_2019.csv"
)


pote = {"2019": liste_des_variables_csg_2019, "2018": liste_des_variables_csg_2018}

# Cell


def get_aggregats_from_row(row, year):
    """
    Parcours les lignes du dataframe et enregistre les agrégats dans le dictionnaire.
    ::row:: une ligne de dataframe
    ::year:: year of the data
    """
    global agregats
    if agregats.get(year) is None:
        agregats[year] = {}
    agregats[year][row["name"]] = {}
    source = "POTE"  # TODO: move it in a function parameter
    agregats[year][row["name"]][source] = {}
    agregats[year][row["name"]][source]["sum"] = row["sum"]
    agregats[year][row["name"]][source]["lenzero"] = row["lenzero"]
    agregats[year][row["name"]][source]["pct_zero"] = round(row["pct_zero"], 2)
    agregats[year][row["name"]][source]["mean"] = row["mean"]


# Cell


for year, df in pote.items():
    _ = df.apply(get_aggregats_from_row, args=[year], axis=1)

# Cell


def get_aggregate_from_df(df, variable_name):
    """
    Permet de récupérer un agrégat de type somme dans le dataframe
    ::df:: Dataframe à lire
    ::variable_name:: Nom de la variable
    """
    return df.loc[df["name"] == variable_name, "sum"].iloc[0]


# Cell


def nested_set(dic, keys, value):
    """
    Allow to set a value in a nested dictionary
    ::dic:: dic to update
    ::keys:: path to value
    ::value:: value to set
    """
    for key in keys[:-1]:
        if dic.get(key):
            dic = dic.get(key)
        else:
            dic = dic.setdefault(key, {})
    dic[keys[-1]] = value


# Cell


prepare_actions = [
    {
        "agg_name": "csg_salaire",
        "agg_source": "ccss",
        "2020": (55_881 + 16_747) * 1e6,
        "2021": (58_807 + 17_216) * 1e6,
        "of_variables": ["csg_imposable_salaire", "csg_deductible_salaire"],
    },
    {
        "agg_name": "csg_retraite",
        "agg_source": "ccss",
        "2020": 20_944_000_000,
        "2021": 21_291_000_000,
        "of_variables": ["csg_imposable_retraite", "csg_deductible_retraite"],
    },
    {
        "agg_name": "csg_chomage",
        "agg_source": "ccss",
        "2020": 1_623_000_000,
        "2021": 1_037_000_000,
        # "of_variables": ["csg_imposable_chomage", "csg_deductible_chomage"]
    },
    {
        "agg_name": "csg_revenus_capital",
        "agg_source": "ccss",
        "2020": 12_559_000_000,
        "2021": 12_344_000_000,
        # "of_variables": ["csg_revenus_capital"]
    },
    {
        "agg_name": "csg_brute",
        "agg_source": "ccss",
        "2020": 121_735_000_000,
        "2021": 127_252_000_000,
        # "of_variables": ["csg"]
    },
    {
        "agg_name": "crds_salaire_prive",
        "agg_source": "acoss",
        "2019": 3_219_000_000,
        "2020": 3_050_000_000,
        "2021": 3_216_000_000,
    },
    {
        "agg_name": "crds_salaire_public_non_titulaire",
        "agg_source": "acoss",
        "2019": 178_000_000,
        "2020": 185_000_000,
        "2021": 196_000_000,
    },
    {
        "agg_name": "crds_salaire_public_titulaire",
        "agg_source": "acoss",
        "2019": 720_000_000,
        "2020": 724_000_000,
        "2021": 744_000_000,
    },
    # CRDS Activité
    # 7.6 * 1_000_000_000 total CRDS 2019 - CRDS Salaire OF 3,947,173,837 € sans recalage
    # Source de l'agrégat : Mail de l'Acoss du 19 octobre 2021
    {
        "agg_name": "crds_salaire",
        "agg_source": "acoss",
        "2019": 4_117_000_000,
        "2020": 3_959_000_000,
        "2021": 4_156_000_000,
        "of_variables": ["crds_salaire"],
    },
    #     {  #  ! FAUX
    #         "agg_name": "crds_retraite",
    #         "agg_source": "acoss",
    #         "2020": 20_944_000_000,
    #         "2021": 21_291_000_000,
    #     },
    #     {  #  ! FAUX
    #         "agg_name": "crds_chomage",
    #         "agg_source": "acoss",
    #         "2020": 208_734_875, #1_623_000_000
    #         "2021": 200_000_000, # 1_037_000_000
    #     },
    #     {  #  ! FAUX
    #         "agg_name": "crds_revenus_capital",
    #         "agg_source": "acoss",
    #         "2020": 12_559_000_000,
    #         "2021": 12_344_000_000,
    #     },
]

# Cell


class Aggregate(BaseModel):
    """
    contain metadata about the aggregate
    """

    agg_year: str
    agg_name: str
    agg_source: str
    agg_type: Optional[str] = "sum"
    agg_value: Optional[int] = None
    ux_name: Optional[str] = None


class Simu(BaseModel):
    """
    contain informations on the simulation to run to compute correction factor
    """

    of_year: str
    of_variables: List[str]


class Action(BaseModel):
    """
    contain Aggregate and optionaly Simu
    """

    agg: Aggregate
    simu: Optional[Simu]


class Actions(BaseModel):
    actions: List[Action]


# Cell
to_process = Actions(actions=[])

for a in prepare_actions:
    if a.get("2019"):
        agg_2019 = Aggregate(
            agg_year="2019",
            agg_name=a["agg_name"],
            agg_source=a["agg_source"],
            agg_value=a["2019"],
        )
        to_process.actions.append(Action(agg=agg_2019))
    agg_2020 = Aggregate(
        agg_year="2020",
        agg_name=a["agg_name"],
        agg_source=a["agg_source"],
        agg_value=a["2020"],
    )
    agg_2021 = Aggregate(
        agg_year="2021",
        agg_name=a["agg_name"],
        agg_source=a["agg_source"],
        agg_value=a["2021"],
    )
    # Factor to compute
    if a.get("of_variables"):
        factor_2021 = Simu(of_year="2021", of_variables=a["of_variables"])
        factor_2022 = Simu(of_year="2022", of_variables=a["of_variables"])
    else:
        factor_2021 = None
        factor_2022 = None
    # Add actions to do
    action = Action(agg=agg_2020)
    to_process.actions.append(action)
    if factor_2021:
        action = Action(agg=agg_2021, simu=factor_2021)
        to_process.actions.append(action)
    action = Action(agg=agg_2021, simu=factor_2022)
    to_process.actions.append(action)

# Cell


def get_factor(annee_de_calcul: str, variables: Union[List, str], aggregate: int):
    """
    Call Open Fisca to run a simulation and return the correction factor
    ::annee_de_calcul:: Year of computation
    ::variables:: a variable or a list of variables to get as output of the simulation
    ::aggregate:: The value of the aggregate to compute the correction factor
    ::return:: correction factor
    """
    variables = [variables] if isinstance(variables, str) else variables
    reform = ReformeSocioFiscale(
        base=annee_de_calcul,
        amendement={},
        output_variables=variables,
    )
    # Compute the value with Open Fisca
    resultat, errors = compute_reform(reform, annee_de_calcul, ignore_recallage=True)
    # Check there is no error
    tc.assertEqual(errors, [])
    of_result = 0
    for v in variables:
        of_result += resultat.state_budget[v]
    # Print an output
    print(
        f"Montant en sortie OF pour {annee_de_calcul} pour la somme de {variables} : {of_result:,.0f}, montant attendu : {aggregate:,.0f}"
    )
    factor = float(aggregate / abs(of_result))
    return factor


# Cell


def process_actions(list_to_process: Actions):
    """
    Execute the actions in the List of Action : store an aggregate value and/or compute a correction factor
    ::list_to_process:: Instance of Actions
    ::return:: Nothing, it update the global variable agregats
    """
    global agregats
    for a in list_to_process.actions:
        year = a.agg.agg_year
        of_year = a.simu.of_year if a.simu else None
        agg_name = a.agg.agg_name
        agg_source = a.agg.agg_source
        print("Processing", agg_name)
        # If we have a value, we set it
        if a.agg.agg_value:
            nested_set(
                agregats,
                [year, agg_name, agg_source, a.agg.agg_type],
                a.agg.agg_value,
            )
        # Get the aggregate value
        agg = agregats[year][agg_name][agg_source][a.agg.agg_type]
        # Compute the correction factor if needed
        if of_year:
            factor = get_factor(of_year, a.simu.of_variables, agg)
            # Check the precision of the factor
            tc.assertGreater(factor, 0.8, msg=f"for {a.agg.agg_name}")
            tc.assertLess(factor, 1.2, msg=f"for {a.agg.agg_name}")
            if not (0.9 < factor < 1.1):
                print(
                    f"process_actions WARNING : Factor for {agg_name} is above 10% error, but below 20% error."
                )
            # Set the factor on the agregate
            nested_set(
                agregats,
                [year, agg_name, agg_source, f"factor_to_{of_year}"],
                factor,
            )
            # Set the factor on the OpenFisca variables for the ERFS data for the ERFS year
            for v in a.simu.of_variables:
                nested_set(
                    agregats,
                    [config.get("YEAR_ERFS"), v, "ERFS", f"factor_to_{of_year}"],
                    factor,
                )


# Cell


def save_agg(agregats):
    with open(config.get("AGREGATS"), mode="w") as file:
        yaml.dump(agregats, file)
        # _ = file.write()
        # _ = file.write(round_trip_dump(agregats, sys.stdout))
