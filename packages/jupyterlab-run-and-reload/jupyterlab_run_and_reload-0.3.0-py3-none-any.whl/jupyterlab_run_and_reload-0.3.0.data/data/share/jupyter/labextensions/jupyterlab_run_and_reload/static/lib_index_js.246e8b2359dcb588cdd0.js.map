{"version":3,"file":"lib_index_js.246e8b2359dcb588cdd0.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAA+D;AACR;AACG;AACd;AAGb;AAC/B;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oEAAgB;AAC/B,eAAe,yEAAgB,EAAE,iEAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA,4DAA4D,+DAAa;AACzE;AACA;AACA;AACA;AACA;AACA,+CAA+C,+DAAa;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,6CAA6C,+DAAa;AAC1D;AACA,0BAA0B,wEAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA,aAAa;AACb;AACA;AACA;AACA,iEAAe,MAAM,EAAC","sources":["webpack://jupyterlab_run_and_reload/./lib/index.js"],"sourcesContent":["import { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { ICommandPalette } from '@jupyterlab/apputils';\nimport { IDocumentManager } from '@jupyterlab/docmanager';\nimport { toArray } from '@lumino/algorithm';\nimport { NotebookActions, NotebookPanel\n// INotebookModel\n } from '@jupyterlab/notebook';\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.reloadAll = 'run-and-reload:run-all-cells-and-reload';\n})(CommandIDs || (CommandIDs = {}));\n// TODO: Change category to run items\nconst PALETTE_CATEGORY = 'Run and reload extension';\n/**\n * Initialization data for the jupyterlab_run_and_reload extension.\n *\n * TODOs:\n * - Add setting: file extensions to reload\n * - Add setting: only reload visible widgets or not\n * - Add toolbar button in notebook panel with run and reload\n * - Also add \"Restart kernel, run all cells and reload PDFs\"\n */\nconst plugin = {\n    id: 'jupyterlab_run_and_reload:plugin',\n    autoStart: true,\n    requires: [IDocumentManager],\n    optional: [ISettingRegistry, ICommandPalette],\n    activate: (app, manager, settingRegistry, palette) => {\n        console.log('JupyterLab extension jupyterlab_run_and_reload is activated!');\n        if (settingRegistry) {\n            settingRegistry\n                .load(plugin.id)\n                .then(settings => {\n                console.log('jupyterlab_run_and_reload settings loaded:', settings.composite);\n            })\n                .catch(reason => {\n                console.error('Failed to load settings for jupyterlab_run_and_reload.', reason);\n            });\n        }\n        const { shell, commands } = app;\n        commands.addCommand(CommandIDs.reloadAll, {\n            label: 'Run All Cells and Reload PDFs',\n            caption: 'Reload all static files after your notebook is finished running all cells.',\n            isEnabled: () => shell.currentWidget instanceof NotebookPanel,\n            execute: async () => {\n                // Get currently selected widget\n                const currentWidget = shell.currentWidget;\n                // If current widget is a notebook then we can run all cells\n                // If not, then this command does not make sense and should not be callable actually\n                if (!(currentWidget instanceof NotebookPanel)) {\n                    return;\n                }\n                function widgetShouldReload(widget) {\n                    const context = manager.contextForWidget(widget);\n                    return context === null || context === void 0 ? void 0 : context.path.endsWith('.pdf');\n                }\n                // Get all attached widgets in the shell\n                const currentWidgets = toArray(shell.widgets());\n                // Obtain the list of widgets that might need to be reloaded after the notebook is finished\n                const widgetsToReload = currentWidgets.filter(widgetShouldReload);\n                const contextsToReload = widgetsToReload.map(widget => manager.contextForWidget(widget));\n                // Connect the openOrReveal function to the fileChanged signal of the relevant widgets\n                contextsToReload.forEach(context => {\n                    context === null || context === void 0 ? void 0 : context.fileChanged.connect((context, model) => {\n                        manager.openOrReveal(context.path);\n                    });\n                });\n                // If current widget is a notebook then we can run all cells\n                if (currentWidget instanceof NotebookPanel) {\n                    // TODO: Add check on result + notification if notebook run was not successfull\n                    await NotebookActions.runAll(currentWidget.content, currentWidget.sessionContext);\n                }\n                // Loop over all widgets in the shell and revert the relevant ones\n                for (const context of contextsToReload) {\n                    context === null || context === void 0 ? void 0 : context.revert();\n                }\n            }\n        });\n        // Add the command to the palette\n        if (palette) {\n            palette.addItem({\n                command: CommandIDs.reloadAll,\n                args: { isPalette: true },\n                category: PALETTE_CATEGORY\n            });\n        }\n    }\n};\nexport default plugin;\n"],"names":[],"sourceRoot":""}