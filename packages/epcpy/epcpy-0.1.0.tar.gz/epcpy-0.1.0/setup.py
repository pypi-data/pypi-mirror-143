# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['epcpy', 'epcpy.epc_schemes', 'epcpy.utils']

package_data = \
{'': ['*']}

entry_points = \
{'console_scripts': ['test = scripts:test']}

setup_kwargs = {
    'name': 'epcpy',
    'version': '0.1.0',
    'description': "A Python module for creation, validation, and transformation of EPC representations as defined in GS1's EPC Tag Data Standard (https://www.gs1.org/standards/rfid/tds).",
    'long_description': '# EPCPY\n[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n\n\nA Python module for creation, validation, and transformation of EPC representations as defined in GS1\'s EPC Tag Data Standard (https://www.gs1.org/standards/rfid/tds).\n\n**Table of contents**\n- [EPCPY](#epcpy)\n  - [Requirements](#requirements)\n  - [Scheme types](#scheme-types)\n  - [Available schemes](#available-schemes)\n  - [Generic parsers](#generic-parsers)\n  - [Example usage](#example-usage)\n    - [SGTIN](#sgtin)\n      - [Pure identity](#pure-identity)\n      - [GS1Keyed](#gs1keyed)\n      - [Tag encoded](#tag-encoded)\n    - [Generic parsing](#generic-parsing)\n  - [Development](#development)\n    - [Testing](#testing)\n    - [Coverage](#coverage)\n    - [Notebook](#notebook)\n\n## Requirements\n- Python >= 3.7\n\n## Scheme types\nEvery scheme is an instance of the `EPCScheme` class, which allows scheme initialization using a constructor which accepts a EPC pure identity such as `urn:epc:id:sgtin:00000950.01093.Serial` or using the class method `from_epc_uri`. Aside from this base class, schemes can also be instances of the `GS1Keyed`, `GS1Element` and/or `TagEncodable` classes. These provide the following methods:\n\n**EPCScheme**\n- *constructor*\n- `from_epc_uri`\n\n**GS1Element / GS1Keyed**\n- `from_gs1_element_string`\n- `gs1_element_string`\n- `gs1_key` (if `GS1Keyed`)\n\n**TagEncodable**\n- `from_binary`\n- `from_hex`\n- `from_base64`\n- `from_tag_uri`\n- `binary`\n- `hex`\n- `base64`\n- `tag_uri`\n\nAn example highlighting the different options for the `SGTIN` scheme can be found [later in this document](#example-usage) .\n\n## Available schemes\n| **Scheme** |  **GS1 element**   |   **GS1 keyed**    | **Tag encodable**  |\n| ---------- | :----------------: | :----------------: | :----------------: |\n| ADI        |                    |                    | :heavy_check_mark: |\n| BIC        |                    |                    |                    |\n| CPI        | :heavy_check_mark: |                    | :heavy_check_mark: |\n| GDTI       | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |\n| GIAI       | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |\n| GID        |                    |                    | :heavy_check_mark: |\n| GINC       | :heavy_check_mark: | :heavy_check_mark: |                    |\n| GRAI       | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |\n| GSIN       | :heavy_check_mark: | :heavy_check_mark: |                    |\n| GSRN       | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |\n| GSRNP      | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |\n| IMOVN      |                    |                    |                    |\n| ITIP       | :heavy_check_mark: |                    | :heavy_check_mark: |\n| PGLN       | :heavy_check_mark: | :heavy_check_mark: |                    |\n| SGCN       | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |\n| SGLN       | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |\n| SGTIN      | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |\n| SSCC       | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |\n| UPUI       | :heavy_check_mark: |                    |                    |\n| USDOD      |                    |                    | :heavy_check_mark: |\n\n## Generic parsers\nThe following generic parser functions are available\n- `base64_to_epc`\n- `binary_to_epc`\n- `hex_to_epc`\n- `tag_uri_to_epc`\n- `epc_pure_identity_to_gs1_keyed`\n- `epc_pure_identity_to_scheme`\n- `epc_pure_identity_to_tag_encodable`\n\n## Example usage\n### SGTIN\n#### Pure identity\nGiven an `SGTIN` in EPC URI representation, `urn:epc:id:sgtin:00000950.01093.Serial`, an epcpy `SGTIN` object can be created as follows\n```python\nfrom epcpy.epc_schemes.sgtin import SGTIN\n\nsgtin = SGTIN.from_epc_uri("urn:epc:id:sgtin:00000950.01093.Serial")\n\n# Alternatively\nsgtin = SGTIN("urn:epc:id:sgtin:00000950.01093.Serial")\n\nsgtin.epc_uri\n# urn:epc:id:sgtin:00000950.01093.Serial\n```\n\n\n#### GS1Keyed\nSince `SGTIN` is `GS1Keyed`, several elements can be derived using\n```python\nsgtin.gs1_element_string()\n# (01)00000095010939(21)Serial\n\nsgtin.gs1_key()\n# 00000095010939\n\nfrom epcpy.epc_schemes.sgtin import GTIN_TYPE\nsgtin.gs1_key(gtin_type=GTIN_TYPE.GTIN8) # GTIN14 is the default\n# 95010939\n```\nAdditionaly, an `SGTIN` can also be constructed from a GS1 element string if a company prefix length is provided\n```python\nSGTIN.from_gs1_element_string("(01)00000095010939(21)Serial", company_prefix_length=8)\n```\n\n#### Tag encoded\nWith some additional information an `SGTIN` can be encoded into a tag, subsequently the tag can for example be represented as tag uri, hexadecimal, base64 or binary string\n```python\nsgtin.tag_uri(binary_coding_scheme=SGTIN.BinaryCodingScheme.SGTIN_198, filter_value=SGTINFilterValue.POS_ITEM)\n# urn:epc:tag:sgtin-198:1.00000950.01093.Serial\n\nsgtin.hex(binary_coding_scheme=SGTIN.BinaryCodingScheme.SGTIN_198, filter_value=SGTINFilterValue.POS_ITEM)\n# 36300001DB011169E5E5A70EC000000000000000000000000000\n\n\nsgtin.base64(binary_coding_scheme=SGTIN.BinaryCodingScheme.SGTIN_198, filter_value=SGTINFilterValue.POS_ITEM)\n# NjAAAdsBEWnl5acOwAAAAAAAAAAAAAAAAAA\n\nsgtin.binary(binary_coding_scheme=SGTIN.BinaryCodingScheme.SGTIN_198, filter_value=SGTINFilterValue.POS_ITEM)\n# 001101100011000000000000000000...\n```\n\nSimilary, given a `SGTIN` tag in hex `36300001DB011169E5E5A70EC000000000000000000000000000`, an `SGTIN` can be constructed\n```python\nSGTIN.from_hex("36300001DB011169E5E5A70EC000000000000000000000000000")\n\n# from_binary, from_base64 and from_tag_uri are available as well\n```\n\n### Generic parsing\nWhen dealing with arbitrary tags epcpy also provides generic parsing options\n```python\nfrom epcpy import hex_to_epc\n\nhex_to_epc("36300001DB011169E5E5A70EC000000000000000000000000000")\n```\n\n## Development\n\nThis project uses [Poetry](https://python-poetry.org/) for project management.\nPoetry must be installed and available in `$PATH`.\nAfter cloning run `poetry install` to install (development) dependencies.\n\n### Testing\nThis module uses the Python unittest library. Run `poetry run tests` for running the tests.\n\n### Coverage\nRun `poetry run coverage run -m unittest discover` to execute all tests with coverage. The resulting coverage can be reported using `poetry run coverage report` for a textual view the terminal and with `poetry run coverage html` for a webpage.\n\n### Notebook\nThere is a sample notebook included in this repository, which can be used to quickly get a hands-on experience with the repository. The notebook might not be completely up-to-date and requires the `jupyter` package to run, which can be installed using `pip install jupyter`.',
    'author': 'Nedap Retail',
    'author_email': 'sander.meinderts@nedap.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/nedap/retail-epcpy',
    'packages': packages,
    'package_data': package_data,
    'entry_points': entry_points,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
